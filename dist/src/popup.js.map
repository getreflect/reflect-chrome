{
  "version": 3,
  "sources": ["../../build/util.js", "../../build/storage.js", "../../build/popup.js"],
  "sourcesContent": ["// util.ts provides utility functions that can be reused in other modules\nexport function addMinutes(date, minutes) {\n    return new Date(date.getTime() + minutes * 60000);\n}\nexport function cleanDomain(urls, exact = false) {\n    // check to see if urls exist\n    if (urls[0] === undefined) {\n        // return empty if not\n        return '';\n    }\n    else {\n        // regex match for url\n        const activeURL = urls[0].match(exact ? /^[\\w]+:\\/{2}([^#?]+)/ : /^[\\w]+:\\/{2}([\\w\\.:-]+)/);\n        // no matching sites, return empty\n        if (activeURL == null) {\n            return '';\n        }\n        else {\n            // strip www.\n            return activeURL[1].replace('www.', '');\n        }\n    }\n}\nexport function insertAfter(newNode, existingNode) {\n    existingNode.parentNode.insertBefore(newNode, existingNode.nextSibling);\n}\nexport function createDivFromHTML(htmlString) {\n    const newDiv = document.createElement('div');\n    newDiv.insertAdjacentHTML('beforeend', htmlString);\n    return newDiv;\n}\nexport function getElementFromForm(id) {\n    return document.getElementById(id);\n}\n", "// storage.ts provides a thin wrapper around the chrome storage api to make it easier to read/write from it\n// you can also find helper functions that read/write to chrome storage\nimport { addMinutes } from './util';\n// helper function to retrive chrome storage object\n// usage:\n//\n// getStorage(null).then(storage => {\n//     ...\n// })\nexport function getStorage() {\n    return new Promise((resolve, reject) => {\n        chrome.storage.sync.get(null, (storage) => {\n            if (chrome.runtime.lastError !== undefined) {\n                reject(chrome.runtime.lastError);\n            }\n            else {\n                resolve(storage);\n            }\n        });\n    });\n}\n// helper function to set fields in chrome storage\n// usage:\n//\n// getStorage({enableBlobs: false}).then(storage => {\n//     ...\n// })\nexport function setStorage(key) {\n    return new Promise((resolve, reject) => {\n        chrome.storage.sync.set(key, () => {\n            if (chrome.runtime.lastError !== undefined) {\n                reject(chrome.runtime.lastError);\n            }\n            else {\n                resolve();\n            }\n        });\n    });\n}\n// Add a single url to blocklist (does nothing if url is already in list)\nexport function addToBlocked(url, callback) {\n    getStorage().then((storage) => {\n        // url = cleanDomain([url]) === '' ? url : cleanDomain([url])\n        if (!storage.blockedSites.includes(url)) {\n            storage.blockedSites.push(url);\n            setStorage({ blockedSites: storage.blockedSites }).then(() => {\n                console.log(`${url} added to blocked sites`);\n                callback ? callback() : () => { };\n            });\n        }\n    });\n}\n// Remove single url from blocklist (does nothing if url is not in list)\nexport function removeFromBlocked(url) {\n    getStorage().then((storage) => {\n        let blockedSites = storage.blockedSites;\n        blockedSites = blockedSites.filter((e) => e !== url);\n        setStorage({ blockedSites: blockedSites }).then(() => {\n            console.log(`removed ${url} from blocked sites`);\n        });\n    });\n}\n// Add a single url to whitelist with associated whitelist duration\n// (replaces any existing entries)\nexport function addToWhitelist(url, minutes) {\n    getStorage().then((storage) => {\n        let whitelistedSites = storage.whitelistedSites;\n        let expiry = addMinutes(new Date(), minutes);\n        whitelistedSites[url] = expiry.toJSON();\n        setStorage({ whitelistedSites: whitelistedSites }).then(() => {\n            console.log(`${url} added to whitelisted sites`);\n        });\n    });\n}\nexport function logIntentToStorage(intentString, intentDate, url) {\n    getStorage().then((storage) => {\n        let intentList = storage.intentList;\n        // getting oldest date value from intent list map\n        let oldest_date = new Date();\n        for (const rawDate in intentList) {\n            const date = new Date(rawDate);\n            if (date < oldest_date) {\n                oldest_date = date;\n            }\n        }\n        // deleting oldest intent to keep intent count under limit\n        if (Object.keys(intentList).length > storage.numIntentEntries) {\n            console.log(`list full, popping ${oldest_date.toJSON()}`);\n            delete intentList[oldest_date.toJSON()];\n        }\n        // adding new intent and date to intent list\n        intentList[intentDate.toJSON()] = {\n            intent: intentString,\n            url: url,\n        };\n        // saving intentList to chrome storage\n        setStorage({ intentList: intentList }).then(() => {\n            console.log(`logged intent \"${intentString}\"`);\n        });\n    });\n}\n", "import { getStorage } from './storage';\nimport { cleanDomain } from './util';\n// when popup is loaded, setup event listeners\ndocument.addEventListener('DOMContentLoaded', () => {\n    // setup listener for toggle\n    const toggleSwitch = document.querySelector('#reflect-toggle');\n    toggleSwitch.addEventListener('change', toggleState, false);\n    // get current state and set approriately\n    getStorage().then((storage) => {\n        // set toggle state to storage value\n        toggleSwitch.checked = storage.isEnabled;\n        setupBlockListener(storage.blockedSites);\n    });\n});\n// function to update background with current toggle state\nfunction toggleState(e) {\n    const port = chrome.runtime.connect({\n        name: 'toggleState',\n    });\n    port.postMessage({ state: e.target.checked });\n    port.disconnect();\n}\n// return what current text of button should be\nfunction getButtonText(domain, url, blockedSites) {\n    return blockedSites.includes(domain) || blockedSites.includes(url) ? 'unblock page.' : 'block page.';\n}\n// setup listener for what block button should do\nfunction setupBlockListener(blockedSites) {\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n        const urls = tabs.map((x) => x.url);\n        const domain = cleanDomain(urls);\n        const url = cleanDomain(urls, true);\n        // not on a page (probably new tab)\n        if (domain === '') {\n            document.getElementById('curDomain').textContent = 'none.';\n            return;\n        }\n        document.getElementById('curDomain').textContent = domain;\n        document.getElementById('block').innerHTML = getButtonText(domain, url, blockedSites);\n        document.getElementById('block').addEventListener('click', () => {\n            const port = chrome.runtime.connect({\n                name: 'blockFromPopup',\n            });\n            // toggle state text and update background script\n            const buttonText = document.getElementById('block').innerHTML;\n            if (buttonText == 'block page.') {\n                port.postMessage({ unblock: false, siteURL: domain });\n                document.getElementById('block').innerHTML = 'unblock page.';\n            }\n            else {\n                port.postMessage({ unblock: true, siteURL: domain });\n                document.getElementById('block').innerHTML = 'block page.';\n            }\n            // cleanup connection\n            port.disconnect();\n        });\n        document.getElementById('blockPath').addEventListener('click', () => {\n            const port = chrome.runtime.connect({\n                name: 'blockFromPopup',\n            });\n            // toggle state text and update background script\n            const buttonText = document.getElementById('block').innerHTML;\n            if (buttonText == 'block page.') {\n                port.postMessage({ unblock: false, siteURL: url });\n                document.getElementById('block').innerHTML = 'unblock page.';\n            }\n            else {\n                port.postMessage({ unblock: true, siteURL: url });\n                document.getElementById('block').innerHTML = 'block page.';\n            }\n            // cleanup connection\n            port.disconnect();\n        });\n    });\n}\n"],
  "mappings": ";;AAIO,uBAAqB,cAAc;AAEtC,QAAI,KAAK,OAAO;AAEZ,aAAO;AAAA;AAIP,wBAAkB,KAAK,GAAG,MAAM,QAAQ,yBAAyB;AAEjE,UAAI,aAAa;AACb,eAAO;AAAA;AAIP,eAAO,UAAU,GAAG,QAAQ,QAAQ;AAAA;AAAA;AAAA;;;ACVzC;AACH,WAAO,IAAI,QAAQ,CAAC;AAChB,aAAO,QAAQ,KAAK,IAAI,MAAM;AAC1B,YAAI,OAAO,QAAQ,cAAc;AAC7B,iBAAO,OAAO,QAAQ;AAAA;AAGtB,kBAAQ;AAAA;AAAA;AAAA;AAAA;;;ACbxB,WAAS,iBAAiB,oBAAoB;AAE1C,UAAM,eAAe,SAAS,cAAc;AAC5C,iBAAa,iBAAiB,UAAU,aAAa;AAErD,iBAAa,KAAK;AAEd,mBAAa,UAAU,SAAQ;AAC/B,yBAAmB,SAAQ;AAAA;AAAA;AAInC;AACI,iBAAa,OAAO,QAAQ,QAAQ;AAAA,MAChC,MAAM;AAAA;AAEV,SAAK,YAAY,CAAE,OAAO,EAAE,OAAO;AACnC,SAAK;AAAA;AAGT;AACI,WAAO,aAAa,SAAS,WAAW,aAAa,SAAS,OAAO,kBAAkB;AAAA;AAG3F;AACI,WAAO,KAAK,MAAM,CAAE,QAAQ,MAAM,eAAe,OAAQ;AACrD,mBAAa,KAAK,IAAI,OAAO,EAAE;AAC/B,qBAAe,YAAY;AAC3B,kBAAY,YAAY,MAAM;AAE9B,UAAI,WAAW;AACX,iBAAS,eAAe,aAAa,cAAc;AACnD;AAAA;AAEJ,eAAS,eAAe,aAAa,cAAc;AACnD,eAAS,eAAe,SAAS,YAAY,cAAc,QAAQ,KAAK;AACxE,eAAS,eAAe,SAAS,iBAAiB,SAAS;AACvD,qBAAa,OAAO,QAAQ,QAAQ;AAAA,UAChC,MAAM;AAAA;AAGV,2BAAmB,SAAS,eAAe,SAAS;AACpD,YAAI,cAAc;AACd,eAAK,YAAY,CAAE,SAAS,OAAO,SAAS;AAC5C,mBAAS,eAAe,SAAS,YAAY;AAAA;AAG7C,eAAK,YAAY,CAAE,SAAS,MAAM,SAAS;AAC3C,mBAAS,eAAe,SAAS,YAAY;AAAA;AAGjD,aAAK;AAAA;AAET,eAAS,eAAe,aAAa,iBAAiB,SAAS;AAC3D,qBAAa,OAAO,QAAQ,QAAQ;AAAA,UAChC,MAAM;AAAA;AAGV,2BAAmB,SAAS,eAAe,SAAS;AACpD,YAAI,cAAc;AACd,eAAK,YAAY,CAAE,SAAS,OAAO,SAAS;AAC5C,mBAAS,eAAe,SAAS,YAAY;AAAA;AAG7C,eAAK,YAAY,CAAE,SAAS,MAAM,SAAS;AAC3C,mBAAS,eAAe,SAAS,YAAY;AAAA;AAGjD,aAAK;AAAA;AAAA;AAAA;",
  "names": []
}
